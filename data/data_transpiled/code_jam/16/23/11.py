def main ( args ) :
    from pychrom import pychrom
    class Main ( object ) :
        def solve ( self ) :
            cin = pychrom.cin ( )
            T = cin.next ( )
            for C in range ( 1 , T + 1 ) :
                N = cin.next ( )
                a = [ ]
                b = [ ]
                for i in range ( N ) :
                    a.append ( cin.next ( ) )
                    b.append ( cin.next ( ) )
            if not self._queue :
                return
            s = self._queue.pop ( )
            if self._queue :
                continue
            self._queue.append ( ( S , T , n , self._graph , self._used , self._potential ) )
            self._queue.append ( ( S , T , n , self._potential , self._weight , self._potential ) )
            self._queue.append ( ( S , T , n , self._weight , self._potential ) )
            self._queue.append ( ( S , T , n , self._weight , self._potential ) )
            self._queue.append ( ( S , T , n , self._weight , self._potential ) )
            self._queue.append ( ( S , T , n , self._weight , self._potential ) )
            self._queue.append ( ( S , T , n , self._weight , self._potential ) )
            self._queue.append ( ( S , T , n , self._weight , self._potential ) )
            self._queue.append ( ( S , T , n , self._weight , self._potential ) )
            self._queue.append ( ( S , T , n , self._weight , self._potential ) )
            self._queue.append ( ( S , T , n , self._weight , self._potential ) )
            self._queue.append ( ( S , T , n , self._weight , self._potential ) )
            self._queue.append ( ( S , T , n , self._weight , self._potential ) )
