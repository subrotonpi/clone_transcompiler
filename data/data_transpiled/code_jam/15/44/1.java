) ",explanation=" Tianren ‚ñÅ Liu " ) public static int [ ] solve ( String input ) throws IOException { final int T = Integer . parseInt ( input ) ; final int R = Integer . parseInt ( input ) ; final int C = Integer . parseInt ( input ) ; final int lcm = ( a * b ) / gcd ( a , b ) ; final Map < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; for ( Map . Entry < Integer , Integer > ra : MA . entrySet ( ) ) { final int ca = ra . getValue ( ) ; for ( Map . Entry < Integer , Integer > rb : MB . entrySet ( ) ) { if ( M . containsKey ( lcm ) ) { M . put ( lcm , ra . getValue ( ) , ca * cb * gcd ( ra . getValue ( ) , rb . getValue ( ) ) ) ; } else { M . put ( lcm , ra . getValue ( ) , ca * cb * gcd ( ra . getValue ( ) , rb . getValue ( ) ) ) ; } } } final Map < Integer , Integer > merge ( MA , MB ) ; final Map < Integer , Integer > M = MA . entrySet ( ) ; for ( Map . Entry < Integer , Integer > rb : MB . entrySet ( ) ) { final int cb = rb . getValue ( ) ; if ( M . containsKey ( rb . getKey ( ) ) ) { M . put ( rb . getKey ( ) , cb ) ; } else { M . put ( rb . getKey ( ) , cb ) ; } } final Map < Integer , Integer > cache = new HashMap < Integer , Integer > ( ) ; final Map < Integer , Integer > solveTF = cache . get ( R ) ; if ( ( R ) >= 1 ) { res = merge ( res , compo ( solveTI ( R - 1 , C ) , new Integer ( 1 ) ) ) ; } if ( R >= 2 ) { switch ( C % 6 ) { case 0 : res = merge ( res , compo ( solveTI ( R - 2 , C ) , new Integer ( 3 ) , new Integer ( 6 ) ) ) ; break ; case 3 : res = merge ( res , compo ( solveTI ( R - 2 , C ) , new Integer ( 3 ) , new Integer ( 4 ) ) ) ; break ; } } if ( R >= 3 ) { if ( C % 4 == 0