def _import ( ) :
    import os
    import time
    import math
    import os
    import os
    import os
    import time
    import os
    import os
    import time
    class ProblemC :
        def __init__ ( self ) :
            self.file_in = '%s.in' % self.file_in
            self.file_out = '%s.out' % self.file_out
            self._file = open ( self.file_in , 'w' )
            self._solve ( self._file , self._file , self._file )
            self._file.flush ( )
            self._file.close ( )
    def dfs ( self , cost , pos , d , s , current_node ) :
        if self.pos == self.max_len :
            self.last = self.pos
        if not self.current_node :
            return
        if self.current_node [ last ] == - 1 or self.current_node [ last ] > cost :
            self.current_node [ last ] = cost
        return
    if self.current_node [ last ] in d :
        if self.current_node [ last ] == - 1 or self.current_node [ last ] > cost :
            self.current_node [ last ] = cost
    else :
        if self.current_node [ last ] in d :
            self.current_node [ last ] = { }
    root = ProblemC ( )
    self.max_len = 0
    def preprocess ( self ) :
        with open ( 'dict.txt' , 'r' ) as f :
            for word in f :
                self.current_node = root
                self.max_len = max ( self.max_len , len ( word ) )
                for i in range ( self.max_len ) :
                    if i not in self.current_node :
                        self.current_node [ i ] = { }
                    self.current_node = self.current_node [ i ]
                self.is_end = True
    def solve ( self , f , self ) :
        self.preprocess ( f )
        start = time.time ( )
        self.test_count = self.test_count
        self.max_len = 5
        for case in range ( 1 , self.test_count ) :
            self.s = self.current_node [ case ] [ - 1 ]
    