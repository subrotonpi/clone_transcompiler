def _ import _ , os , sys , os , sys , _ ) : return sys.stdin
import readline
import readline
import readline
import readline
import readline
import readline.parse_input
import readline.parse_input
import readline.parse_input
import readline.parse_input
import readline.parse_output
import tokenize.parse_input
import locale
import os.path
import os.environ
import locale
import os.environ
import locale
import tokenize.parse_input
import tokenize.parse_input
import tokenize.parse_input
import tokenize.parse_output
import tokenize.parse_input
import tokenize.parse_input
import random
import time
mod = 1000002013
def solve ( ) :
    for test in range ( 1 , mod ) :
        n = randint ( 0 , mod )
        pairs = [ [ random.randint ( 0 , mod ) for mod in range ( mod ) ] for i in range ( 3 ) ]
        answer = solve ( n , pairs )
        print ( "Case #%d: %d" % ( test , answer ) )
def solve ( ) :
    try :
        readline.parse_input
    except AttributeError :
        pass
    else :
        readline.parse_input = tokenize.parse_input
    return ( "".join ( [ "\n" ] + [ "%d" % ( mod ) for mod in range ( mod ) ] ) )
def solve ( ) :
    for test in range ( 1 , mod ) :
        n = randint ( 0 , mod )
        pairs = [ [ random.randint ( 0 , mod ) for mod in range ( mod ) ] for i in range ( 3 ) ]
        answer = solve ( n , pairs )
        print ( "Case #%d: %d" % ( test , answer ) )
def solve ( ) :
    for test in range ( 1 , mod ) :
        for i in range ( 0 , mod ) :
            events [ 2 * i + 0 ] = [ i , i ]
    return [ ( ( answer + ( cost ( dist , n ) * exit ) ) % MOD ) for i in range ( 0 , mod ) ]
return solve ( )
