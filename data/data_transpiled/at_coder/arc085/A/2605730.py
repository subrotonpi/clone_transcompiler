def main ( ) : return
def main ( ) : return
n , m = ni ( )
pl ( ( 1900 * m + 100 * ( n - m ) ) * int ( math.pow ( 2 , m ) ) )
flush ( )
def last_lower_index ( array , lo ) : return last_lower_or_equal_index ( array , lo )
def last_lower_index ( array , lo ) : return next_int ( array , lo )
def last_lower_index ( array , lo ) : return next_int ( array , lo )
def last_lower_index ( array , lo ) : return next_int ( array , lo )
def last_lower_index ( array , lo ) : return next_int ( array , lo )
def last_byte_array ( array , lo ) : return next_int ( array , lo )
def gcd ( a , b ) :
    if a > b : a %= b
    while a > b : a += b
    if a % b == 1 : return a
    a %= b
def mod_pow ( a , mod ) :
    c = 1
    while b > 0 : c = ( c * a ) % mod
    a = ( a * a ) % mod
    b //= 2
def is_printable_char ( c ) : return 33 <= c <= 126
def skip_unprintable ( ) :
    while has_next_byte ( ) and not is_printable_char ( array [ ptr ] ) :
        ptr += 1
    while has_next_byte ( ) and not is_printable_char ( array [ ptr ] ) :
        ptr += 1
    return p + mod
def next ( ) :
    if not has_next_byte ( ) : raise StopIteration
    s = [ ]
    for b in read_bytes ( ) :
        pl ( ( t - time ) / 1000000000.0 )
    return ''.join ( s )
def sorted_index ( array ) :
    a = array.array
    index = [ ]
    for i in range ( len ( array ) ) :
        res.append ( array [ i ] )
    n = 0
    minus = False
    b = read_byte ( )
    index.append ( array [ 0 ] )
def stem ( s ) :
    if s <= 1 : return s
    h = s + 1
    mergesort_index ( index , s , h )
return main
